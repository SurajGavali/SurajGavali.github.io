<!DOCTYPE html>
<html class="no-js" lang="en">
<head>

    <title>Virtual Memory(Operating System)</title>

    <!--- basic page needs
    ================================================== -->
   
    <meta name="description" content="">
    <meta name="author" content="">

   <!-- mobile specific metas
    ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- CSS
    ================================================== -->
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="../css/vendor.css">

    <!-- script
    ================================================== -->
    <script src="../js/modernizr.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=c&amp;skin=sons-of-obsidian"></script>
     <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=shell&amp;skin=sons-of-obsidian"></script>

    <!-- favicons
    ================================================== -->
    <link rel="apple-touch-icon" sizes="180x180" href="../logo.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../logo.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../logo.png">
    <link rel="manifest" href="site.webmanifest">

</head>

<body id="top">


    <!-- preloader
    ================================================== -->
    <div id="preloader">
        <div id="loader"></div>
    </div>


    <!-- header
    ================================================== -->
    <header class="s-header">

        <div class="row s-header__content">

            <div class="s-header__logo">
                <a class="logo" href="../index.html">
                    <img src="../images/logo.png" alt="Homepage">
                </a>
            </div>

            <nav class="s-header__nav-wrap">

                <h2 class="s-header__nav-heading h6">Site Navigation</h2>

                <ul class="s-header__nav">
                    <li><a href="../index.html" title="">Home</a></li>
                    <li class="has-children">
                        <a href="#0" title="">Categories</a>
                        <ul class="sub-menu">
                            <li><a href="ctechnical.html">Technical</a></li>
                            <li><a href="cart.html">Art</a></li>
                            <li><a href="cphotography.html">Photography</a></li>
                            <!-- <li><a href="category.html">Vacation</a></li>
                            <li><a href="category.html">Work</a></li>
                            <li><a href="category.html">Health</a></li>
                            <li><a href="category.html">Family</a></li>
                            <li><a href="category.html">Relationship</a></li> -->
                        </ul>
                    </li>
                   <!--  <li class="has-children current">
                        <a href="#0" title="">Blog</a>
                        <ul class="sub-menu">
                        <li><a href="single-video.html">Video Post</a></li>
                        <li><a href="single-audio.html">Audio Post</a></li>
                        <li><a href="single-gallery.html">Gallery Post</a></li>
                        <li><a href="single-standard.html">Standard Post</a></li>
                        </ul>
                    </li> -->
                    <!-- <li><a href="styles.html" title="">Styles</a></li> -->
                    <li><a href="about.html" title="">About</a></li>
                    <li><a href="contact.html" title="">Contact</a></li>
                </ul> <!-- end header__nav -->

                <a href="#0" title="Close Menu" class="s-header__overlay-close close-mobile-menu">Close</a>

            </nav> <!-- end header__nav-wrap -->
                   
            <a class="s-header__toggle-menu" href="#0" title="Menu"><span>Menu</span></a>
            
            <div class="s-header__search">
                    
                <form role="search" method="get" class="s-header__search-form" action="#">
                    <label>
                        <span class="hide-content">Search for:</span>
                        <input type="search" class="s-header__search-field" placeholder="Type Your Keywords" value="" name="s" title="Search for:" autocomplete="off">
                    </label>
                    <input type="submit" class="s-header__search-submit" value="Search">
                </form>

                <a href="#0" title="Close Search" class="s-header__overlay-close">Close</a>

            </div> <!-- end search wrap --> 

            <a class="s-header__search-trigger" href="#">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 18a7.952 7.952 0 004.897-1.688l4.396 4.396 1.414-1.414-4.396-4.396A7.952 7.952 0 0018 10c0-4.411-3.589-8-8-8s-8 3.589-8 8 3.589 8 8 8zm0-14c3.309 0 6 2.691 6 6s-2.691 6-6 6-6-2.691-6-6 2.691-6 6-6z"></path></svg>
            </a>

        </div> <!-- end s-header__content -->

    </header> <!-- end header -->


    <!-- content
    ================================================== -->
    <section class="s-content s-content--single">
        <div class="row">
            <div class="column large-12">

                <article class="s-post entry format-standard">
                    <a href="menu.html"><h3 class="s-content__title s-content__title--post" style="font-size: 20px;">Go to index page</h3></a>

                    <h2 class="s-content__title s-content__title--post">Virtual Memory</h2>
                    
                </article>

                <article class="s-post entry format-standard">
                    
                    <h2 class="s-content__title s-content__title--post" style="text-align: center; font-size: 25px; color:  red;">Virtual Memory != Virtual Address</h2>

                    <h2 class="s-content__title s-content__title--post" style="text-align: left; font-size: 30px;">‚óè Virtual Memory</h2>
                    <p class="lead">A memory management technique
                        employed by OS (of course, with hardware support)</p>

                    <h2 class="s-content__title s-content__title--post" style="text-align: left; font-size: 30px;">‚óè Virtual Address</h2>
                    <p class="lead">Address issued by CPU‚Äôs execution
                        unit, later converted by MMU to physical address</p>

                    <h2 class="s-content__title s-content__title--post" style="text-align: left; font-size: 30px;">Some problems with schemes
                        discussed so far</h2>

                    <p class="lead">‚óè Code needs to be in memory to execute, but entire program rarely used.</p>
                    <p class="lead">‚óè Error code, unusual routines, large data structures.</p>
                    <p class="lead">‚óè Entire program code not needed at same time.</p>
                    <p class="lead">‚óè Consider ability to execute partially-loaded program.</p>
                    <p class="lead">‚óè Program no longer constrained by limits of physical memory i.e if processor is of 32 bit and actual 
                        physical memory is of 2 GB condition.
                    </p>
                    <p class="lead">‚óè Program and number of programs could be larger than physical memory.</p>

                    <h2 class="s-content__title s-content__title--post" style="text-align: left; font-size: 30px;">What is virtual memory?</h2>
                    <p class="lead" style="color: blue;">The problems that we are discussed so far, the approuch of virtual memory tries to 
                        solve these problems.</p>
                    <p class="lead">‚óè virtual memory is a separation of user(compiler or any program) logical memory from physical memory.</p>
                    <h2 class="s-content__title s-content__title--post" style="text-align: left; font-size: 25px;">By using virtual memory 
                    we get following advantages :</h2>

                    <p class="lead">‚óè Only part of the program needs to be in memory for execution</p>
                    <p class="lead">‚óè Logical address space can therefore be much larger than physical address space</p>
                    <p class="lead">‚óè Allows address spaces to be shared by several processes</p>
                    <p class="lead">‚óè Allows for more efficient process creation</p>
                    <p class="lead">‚óè More programs running concurrently</p>
                    <p class="lead">‚óè Less I/O needed to load or swap processes</p>

                    <h2 class="s-content__title s-content__title--post" style="text-align: left; font-size: 25px;">Virtual memory can be 
                        implemented via:
                    </h2>
                    <p class="lead">1. Demand paging</p>
                    <p class="lead">2. Demand segmentation</p>
                    <p class="lead">Nowdays only Demand paging is used heavily so we will study only Demand paging üòÉ.</p>

                    <p class="lead">Virtual memory involves the separation of logical memory as perceived
                        by users from physical memory. This separation allows an extremely large
                        virtual memory to be provided for programmers when only a smaller physical
                        memory is available (see below diagram). Virtual memory makes the task of programming much easier, because the programmer no longer needs to worry about
                        the amount of physical memory available;</p>
                    <div class="s-content__media">
                        <div class="s-content__post-thumb"> 
                            <img src="Screenshot (435).png" 
                                    srcset="Screenshot (435).png 2100w, 
                                            Screenshot (435).png 1050w, 
                                            Screenshot (435).png 525w" style="width: 100%; margin-left: 0px" alt="">
                        </div>
                    </div> <!-- end s-content__media -->
                    <p class="lead">The virtual address space of a process refers to the logical (or virtual) view
                        of how a process is stored in memory. Typically, this view is that a process
                        begins at a certain logical address‚Äîsay, address 0‚Äîand exists in contiguous
                        memory, as shown in below figure.though, that in fact physical memory may be organized in page frames and that the physical page
                        frames assigned to a process may not be contiguous. It is up to the memorymanagement unit (MMU) to map logical pages to physical page frames in
                        memory.</p>
                        <div class="s-content__media">
                            <div class="s-content__post-thumb"> 
                                <img src="Screenshot (436).png" 
                                        srcset="Screenshot (436).png 2100w, 
                                                Screenshot (436).png 1050w, 
                                                Screenshot (436).png 525w" style="width: 100%; margin-left: 0px" alt="">
                            </div>
                        </div> <!-- end s-content__media -->
                    <p class="lead">The large blank
                        space (or hole) between the heap and the stack is part of the virtual address
                        space but will require actual physical pages only if the heap or stack grows.</p>
                    <p class="lead" style="color: blue;">Virtual address spaces that include holes are known as sparse address spaces.</p>
                    <p class="lead">Virtual space enables : 
                         </p>
                    <p class="lead">1. Address spaces
                        with holes left for growth,
                        dynamically linked libraries, etc.</p>
                    <p class="lead">2. System libraries shared via
                        mapping into virtual address space</p>
                    <p class="lead">3. Shared memory by mapping pages
                        read-write into virtual address
                        space
                        </p>
                    <p class="lead">4. Pages can be shared during
                        fork(), speeding process
                        creation</p>

                        <div class="s-content__media">
                            <div class="s-content__post-thumb"> 
                                <img src="Screenshot (437).png" 
                                        srcset="Screenshot (437).png 2100w, 
                                                Screenshot (437).png 1050w, 
                                                Screenshot (437).png 525w" style="width: 100%; margin-left: 0px" alt="">
                            </div>
                        </div> <!-- end s-content__media -->
                    <p class="lead">In addition to separating logical memory from physical memory, virtual
                        memory allows files and memory to be shared by two or more processes
                        through page sharing (Section 8.5.4). This leads to the following benefits:</p>
                    <p class="lead">1. System libraries can be shared by several processes through mapping of the
                        shared object into a virtual address space. Although each process considers
                        the libraries to be part of its virtual address space, the actual pages where
                        the libraries reside in physical memory are shared by all the processes
                        (Figure 9.3). Typically, a library is mapped read-only into the space of each
                        process that is linked with it.</p>
                    <p class="lead">Similarly, processes can share memory. Recall that two
                        or more processes can communicate through the use of shared memory.
                        Virtual memory allows one process to create a region of memory that it can
                        share with another process. Processes sharing this region consider it part
                        of their virtual address space, yet the actual physical pages of memory are
                        shared, much as is illustrated in above figure</p>


                    <h2 class="s-content__title s-content__title--post">Demand Paging</h2>

                    <p class="lead">With demand-paged virtual memory, </p>
                    <p class="lead">‚óè Pages are loaded only when they are
                        demanded during program execution. Pages that are never accessed are thus
                        never loaded into physical memory.</p>
                    <p class="lead">‚óè Less I/O needed, no unnecessary I/O</p>
                    <p class="lead">‚óè Less memory needed </p>
                    <p class="lead">‚óè Faster response and more users.</p>
                    <p class="lead">Whenever page is needed check reference to it ,</p>
                    <p class="lead">invalid reference --> abort</p>
                    <p class="lead">not-in-memory --> bring to memory</p>
                    <p class="lead" style="color: rgb(142, 193, 238);">A lazy swapper never swaps a page into memory unless that page will be
                        needed. In the context of a demand-paging system, use of the term ‚Äúswapper‚Äù
                        is technically incorrect. A swapper manipulates entire processes, whereas a
                        pageris concerned with the individual pages of a process. We thus use ‚Äúpager,‚Äù
                        rather than ‚Äúswapper,‚Äù in connection with demand paging.</p>


                        <h2 class="s-content__title s-content__title--post" style="text-align: left; font-size: 25px;">Paging In and Paging Out</h2>
                    
                        <div class="s-content__media">
                            <div class="s-content__post-thumb"> 
                                <img src="Screenshot (438).png" 
                                        srcset="Screenshot (438).png 2100w, 
                                                Screenshot (438).png 1050w, 
                                                Screenshot (438).png 525w" style="width: 100%; margin-left: 0px" alt="">
                            </div>
                        </div> <!-- end s-content__media -->
                    <p class="lead">The valid‚Äìinvalid bit scheme described previously can be used for this
                        purpose.</p>
                    <p class="lead">This time, however, when this bit is set to ‚Äúvalid,‚Äù the associated page
                        is both legal and in memory. If the bit is set to ‚Äúinvalid,‚Äù the page either is not
                        valid (that is, not in the logical address space of the process) or is valid but
                        is currently on the disk.</p>


                        <div class="s-content__media">
                            <div class="s-content__post-thumb"> 
                                <img src="Screenshot (439).png" 
                                        srcset="Screenshot (439).png 2100w, 
                                                Screenshot (439).png 1050w, 
                                                Screenshot (439).png 525w" style="width: 100%; margin-left: 0px" alt="">
                            </div>
                        </div> <!-- end s-content__media -->
                    <p class="lead">The page-table entry for a page that is brought into
                        memory is set as usual, but the page-table entry for a page that is not currently
                        in memory is either simply marked invalid or contains the address of the page
                        on disk. This situation is depicted in above Figure.</p>



                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">Page fault</h2>
                    <p class="lead">‚óè If there is a reference to a page, first reference to that page will trap to operating
                        system called as "page fault".</p>
                    <p class="lead">‚óè Operating system looks at another table to decide:</p>
                    <p class="lead">1. Invalid reference --> abort</p>
                    <p class="lead">2. Just not in memory :</p>
                    <p class="lead">--> Get empty frame</p>
                    <p class="lead">--> Swap page into frame via scheduled disk operation</p>
                    <p class="lead">--> Reset tables to indicate page now in memory</p>
                    <p class="lead">--> Set validation bit = v</p>
                    <p class="lead">--> Restart the instruction that caused the page fault</p>
                    <p class="lead">For more understanding refer the below diagram.</p>


                    <div class="s-content__media">
                        <div class="s-content__post-thumb"> 
                            <img src="Screenshot (440).png" 
                                    srcset="Screenshot (440).png 2100w, 
                                            Screenshot (440).png 1050w, 
                                            Screenshot (440).png 525w" style="width: 100%; margin-left: 0px" alt="">
                        </div>
                    </div> <!-- end s-content__media -->

                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">Pure demand paging</h2>

                    <p class="lead">In the extreme case, we can start executing a process with no pages in
                        memory. </p>
                    <p class="lead">When the operating system sets the instruction pointer to the first 
                        instruction of the process, which is on a non-memory-resident page, the process
                        immediately faults for the page. </p>
                    <p class="lead">After this page is brought into memory, the
                        process continues to execute, faulting as necessary until every page that it
                        needs is in memory. At that point, it can execute with no more faults. This
                        scheme is pure demand paging: never bring a page into memory until it is
                        required.</p>

                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">locality of reference</h2>

                    <p class="lead">Theoretically, some programs could access several new pages of memory
                        with each instruction execution (one page for the instruction and many for
                        data), possibly causing multiple page faults per instruction. </p>
                    <p class="lead">This situation
                        would result in unacceptable system performance. Fortunately, analysis of
                        running processes shows that this behavior is exceedingly unlikely. Programs
                        tend to have locality of reference.</p>
                    <p class="lead" style="color: red;">The hardware to support demand paging is the same as the hardware for
                        paging and swapping:</p>
                    <p class="lead">--> Page table with valid / invalid bit</p>
                    <p class="lead">--> Secondary memory (swap device with swap space)</p>
                    <p class="lead">--> Instruction restart</p>


                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">Instruction restart</h2>

                    <p class="lead">A crucial requirement for demand paging is the ability to restart any
                        instruction after a page fault. </p>
                    <p class="lead">Because we save the state (registers, condition
                        code, instruction counter) of the interrupted process when the page fault
                        occurs, we must be able to restart the process in exactly the same place and
                        state, except that the desired page is now in memory and is accessible.</p>
                    <p class="lead" style="color: blue;">A page fault may occur at any memory
                        reference,</p>
                    <p class="lead">1. If the page fault occurs on the instruction fetch, we can restart by
                        fetching the instruction again.</p>
                    <p class="lead">2. If a page fault occurs while we are fetching an
                        operand, we must fetch and decode the instruction again and then fetch the
                        operand.</p>
                    <p class="lead">As a worst-case example, consider a three-address instruction such as ADD
                        the content of A to B, placing the result in C.</p>
                    <p class="lead">These are the steps to execute this
                        instruction : (1. Fetch and decode the instruction (ADD).
                        2. Fetch A.
                        3. Fetch B.
                        4. Add A and B.
                        5. Store the sum in C.)</p>
                    <p class="lead">If we fault when we try to store in C (because C is in a page not currently
                        in memory), we will have to get the desired page, bring it in, correct the
                        page table, and restart the instruction.</p>
                    <p class="lead">The restart will require fetching the
                        instruction again, decoding it again, fetching the two operands again, and
                        then adding again.</p>
                    <p class="lead">The major difficulty arises when one instruction may modify several
                        different locations. For example, consider the IBM System 360/370 MVC (move
                        character) instruction, which can move up to 256 bytes from one location to
                        another (possibly overlapping) location. If either block (source or destination)
                        straddles a page boundary, a page fault might occur after the move is partially
                        done. In addition, if the source and destination blocks overlap, the source
                        block may have been modified, in which case we cannot simply restart the
                        instruction.</p>


                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">Page fault handling</h2>

                    <p class="lead">1) Trap to the operating system</p>
                    <p class="lead">2) Save the user registers and process state
                    </p>
                    <p class="lead">3) Determine that the interrupt was a page fault</p>
                    <p class="lead">4) Check that the page reference was legal and determine the location of the
                        page on the disk</p>
                    <p class="lead">5) Issue a read from the disk to a free frame:</p>
                    <p class="lead">--> Wait in a queue for this device until the read request is serviced
                    </p>
                    <p class="lead">--> Wait for the device seek and/or latency time
                    </p>
                    <p class="lead">--> Begin the transfer of the page to a free frame</p>
                    <p class="lead">6) While waiting, allocate the CPU to some other user</p>
                    <p class="lead">7) Receive an interrupt from the disk I/O subsystem (I/O completed)
                    </p>
                    <p class="lead">8) Save the registers and process state for the other user
                    </p>
                    <p class="lead">9) Determine that the interrupt was from the disk</p>
                    <p class="lead">10)Correct the page table and other tables to show page is now in memory</p>
                    <p class="lead">11)Wait for the CPU to be allocated to this process again
                    </p>
                    <p class="lead">12)Restore the user registers, process state, and new page table, and then
                        resume the interrupted instruction</p>


                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">Performance of demand paging</h2>

                    <p class="lead" style="color: red;">Page Fault Rate 0 <= p <= 1</p>
                    <p class="lead">‚óè if p = 0 no page faults </p>
                    <p class="lead">‚óè if p = 1, every reference is a fault
                    </p>
                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">Effective Access Time (EAT)</h2>

                    <p class="lead">EAT = (1 ‚Äì p) x memory access + p x (page fault overhead + swap page out + swap page in + restart overhead)</p>
                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">Example,</h2>

                    <p class="lead">1. Memory access time = 200 nanoseconds and Average page-fault service time = 8 milliseconds</p>
                    <p class="lead">--> EAT = (1 ‚Äì p) x 200 + p (8 milliseconds) </p>
                    <p class="lead">= (1 ‚Äì p) x 200 + p x 8,000,000</p>
                    <p class="lead">= 200 + p x 7,999,800</p>
                    <p class="lead">If one access out of 1,000 causes a page fault, then
                    </p>
                    <p class="lead">EAT = 8.2 microseconds.(This is a slowdown by a factor of 40!!)</p>
                    <p class="lead" style="color: red;">If want performance degradation < 10 percent</p>
                    <p class="lead">--> 220 > 200 + 7,999,800 x p</p>
                    <p class="lead">20 > 7,999,800 x p</p>
                    <p class="lead">p < 0.0000025</p>
                    <p class="lead">< one page fault in every 400,000 memory accesses</p>

                    <h2 class="s-content__title s-content__title--post" style="font-size: 40px; text-align: left;">Optimization methods</h2>

                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">1. Copy On Write(COW)</h2>

                    <p class="lead">This technique
                        provides rapid process creation and minimizes the number of new pages that
                        must be allocated to the newly created process.</p>
                    <p class="lead">In this the parent and child processes initially to share the
                        same pages.</p>
                    <p class="lead">These shared pages are marked as copy-on-write pages, meaning
                        that if either process writes to a shared page, a copy of the shared page is
                        created. see below diagram.</p>
                        <p class="lead" style="text-align: center;">Before process 1 modifies page C.</p>
                        <div class="s-content__media">
                            <div class="s-content__post-thumb"> 
                                <img src="Screenshot (441).png" 
                                        srcset="Screenshot (441).png 2100w, 
                                                Screenshot (441).png 1050w, 
                                                Screenshot (441).png 525w" style="width: 100%; margin-left: 0px" alt="">
                            </div>
                        </div> <!-- end s-content__media -->
                    
                    <p class="lead" style="text-align: center;">After process 1 modifies page C.</p>
                    <div class="s-content__media">
                        <div class="s-content__post-thumb"> 
                            <img src="Screenshot (442).png" 
                                    srcset="Screenshot (442).png 2100w, 
                                            Screenshot (442).png 1050w, 
                                            Screenshot (442).png 525w" style="width: 100%; margin-left: 0px" alt="">
                        </div>
                    </div> <!-- end s-content__media -->
                    
                    <p class="lead" style="color: brown;">For example, assume that the child process attempts to modify a page
                        containing portions of the stack, with the pages set to be copy-on-write.</p>
                    <p class="lead" style="color: brown;">The
                        operating system will create a copy of this page, mapping it to the address space
                        of the child process.</p>
                    <p class="lead">The child process will then modify its copied page and not
                        the page belonging to the parent process. Obviously, when the copy-on-write
                        technique is used, only the pages that are modified by either process are copied;
                        all unmodified pages can be shared by the parent and child processes. </p>
                    <p class="lead" style="color: red;"> Note,
                        that only pages that can be modified need be marked as copy-on-write. Pages
                        that cannot be modified (pages containing executable code) can be shared by
                        the parent and child. </p>
                    <p class="lead">When it is determined that a page is going to be duplicated using 
                        copyon-write, it is important to note the location from which the free page will
                        be allocated.</p>
                    <p class="lead">Many operating systems provide a "pool" of free pages for such
                        requests. </p>
                    <p class="lead">These free pages are typically allocated when the stack or heap for a
                        process must expand or when there are copy-on-write pages to be managed.</p>
                    <p class="lead">Operating systems typically allocate these pages using a technique known as
                        "zero-fill-on-demand". Zero-fill-on-demand pages have been zeroed-out before
                        being allocated, thus erasing the previous contents.</p>

                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">vfork()</h2>

                    <p class="lead">which operates
                        differently from fork() with copy-on-write. </p>
                    <p class="lead">With vfork(), the parent process
                        is suspended, and the child process uses the address space of the parent.
                        Because vfork() does not use copy-on-write, if the child process changes
                        any pages of the parent‚Äôs address space, the altered pages will be visible to the
                        parent once it resumes.</p>
                    <p class="lead">vfork() is an extremely
                        efficient method of process creation and is sometimes used to implement UNIX
                        command-line shell interfaces.</p>
                    
                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">2. Page Replacement</h2>
                    <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">What if no free frame?</h2>

                    <p class="lead">If we increase our degree of multiprogramming, we are "over-allocating"
                        memory</p>
                    <p class="lead">If we run six processes, each of which is ten pages in size but actually
                        uses only five pages, we have higher CPU utilization and throughput, with
                        ten frames to spare.</p>
                    <p class="lead">It is possible, however, that each of these processes, for a
                        particular data set, may suddenly try to use all ten of its pages, resulting in a
                        need for sixty frames when only forty are available.</p>
                    <p class="lead">We also need to consider that free frames are also demanded from kernel, I/O buffers, etc.</p>
                    <p class="lead">One of the solution for allocating free frames is page replacement - find some page in 
                        memory, but not really in use, page it out.</p>
                    <p class="lead">‚óè Same page may be brought into memory several times</p>

                    <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">Strategies for performance</h2>

                    <p class="lead">‚óè Prevent over-allocation of memory by modifying page-fault service routine to
                        include page replacement</p>
                    <p class="lead">‚óè Use modify (dirty) bit to reduce overhead of page transfers ‚Äì only modified
                        pages are written to disk</p>
                    <p class="lead" style="color: blue;">Page replacement completes separation between logical memory and physical
                        memory ‚Äì large virtual memory can be provided on a smaller physical memory</p>

                        <div class="s-content__media">
                            <div class="s-content__post-thumb"> 
                                <img src="Screenshot (443).png" 
                                        srcset="Screenshot (443).png 2100w, 
                                                Screenshot (443).png 1050w, 
                                                Screenshot (443).png 525w" style="width: 100%; margin-left: 0px" alt="">
                            </div>
                        </div> <!-- end s-content__media -->

                    <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">Basic Page Replacement</h2>

                    <p class="lead">1) Find the location of the desired page on the disk.</p>
                    <p class="lead">2) Find a free frame:</p>
                    <p class="lead">--> a. If there is a free frame, use it.</p>
                    <p class="lead">--> b. If there is no free frame, use a page-replacement algorithm to select
                        a victim frame.</p>
                    <p class="lead">--> c. Write the victim frame to the disk; change the page and frame tables
                        accordingly.</p>
                    <p class="lead" style="color: red;">Write victim frame to disk if dirty</p>
                    <p class="lead">3) Read the desired page into the newly freed frame; change the page and
                        frame tables.</p>
                    <p class="lead">4) Continue the user process from where the page fault occurred.</p>
                    <p class="lead" style="color: red;">Note now potentially 2 page transfers for page fault ‚Äì increasing EAT
                        P</p>

                        <div class="s-content__media">
                            <div class="s-content__post-thumb"> 
                                <img src="Screenshot (444).png" 
                                        srcset="Screenshot (444).png 2100w, 
                                                Screenshot (444).png 1050w, 
                                                Screenshot (444).png 525w" style="width: 100%; margin-left: 0px" alt="">
                            </div>
                        </div> <!-- end s-content__media -->

                    <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">Now there are two problems 
                        to be solved</h2>

                    <p class="lead">1. Frame-allocation algorithm</p>
                    <p class="lead">which determines how many frames to give each process and which frames to replace.</p>
                    <p class="lead">2. Page-replacement algorithm</p>
                    <p class="lead">Want lowest page-fault rate on both first access and reaccess.</p>
                    <p class="lead">There are many different page-replacement algorithms. Every operating
                        system probably has its own replacement scheme.</p>
                    <p class="lead" style="color: red;">How do we select a
                        particular replacement algorithm? In general, we want the one with the lowest
                        page-fault rate.</p>
                    <p class="lead">We evaluate an algorithm by running it on a particular string of memory
                        references and computing the number of page faults. </p>
                    <p class="lead">The string of memory
                        references is called a "reference string".</p>
                    <p class="lead">We can generate reference strings
                        artificially (by using a random-number generator, for example), or we can trace
                        a given system and record the address of each memory reference.</p>
                    <p class="lead">To reduce the number of data, we use two facts.</p>
                    <p class="lead">1. for a given page size (and the page size is generally fixed by the
                        hardware or system), we need to consider only the page number, rather than
                        the entire address.</p>
                    <p class="lead">2. if we have a reference to a page p,then any references
                        to page p that immediately follow will never cause a page fault. Page p will
                        be in memory after the first reference, so the immediately following references
                        will not fault.</p>
                    <p class="lead">Obviously, as the number of frames available increases, the number
                        of page faults decreases.</p>
                    <p class="lead">In general, we expect a curve such as that in Figure below</p>

                    <div class="s-content__media">
                        <div class="s-content__post-thumb"> 
                            <img src="Screenshot (445).png" 
                                    srcset="Screenshot (445).png 2100w, 
                                            Screenshot (445).png 1050w, 
                                            Screenshot (445).png 525w" style="width: 100%; margin-left: 0px" alt="">
                        </div>
                    </div> <!-- end s-content__media -->
                    <p class="lead">As the
                        number of frames increases, the number of page faults drops to some minimal
                        level. Of course, adding physical memory increases the number of frames.</p>
                    <p class="lead" style="color: blue;">In all our examples, the reference string is</p>
                    <p class="lead" style="color: rgb(199, 43, 63);">7,0,1,2,0,3,0,4,2,3,0,3,0,3,2,1,2,0,1,7,0,1</p>

                    <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">FIFO Page Replacement</h2>
                    <p class="lead">The simplest page-replacement algorithm is a first-in, first-out (FIFO) algorithm.</p>
                    <p class="lead">When a page must be replaced, the oldest
                        page is chosen.</p>
                        <div class="s-content__media">
                            <div class="s-content__post-thumb"> 
                                <img src="Screenshot (446).png" 
                                        srcset="Screenshot (446).png 2100w, 
                                                Screenshot (446).png 1050w, 
                                                Screenshot (446).png 525w" style="width: 100%; margin-left: 0px" alt="">
                            </div>
                        </div> <!-- end s-content__media -->
                    <p class="lead">For our example reference string, our three frames are initially empty. </p>
                    <p class="lead">The
                        first three references (7, 0, 1) cause page faults and are brought into these empty
                        frames.</p>
                    <p class="lead">The next reference (2) replaces page 7, because page 7 was brought in
                        first. </p>
                    <p class="lead">Since 0 is the next reference and 0 is already in memory, we have no fault
                        for this reference.</p>
                    <p class="lead">The first reference to 3 results in replacement of page 0, since
                        it is now first in line.</p>
                    <p class="lead">Because of this replacement, the next reference, to 0, will fault.</p>
                    <p class="lead">Page 1 is then replaced by page 0. This process continues as shown in
                        above figure</p>
                    <p class="lead"> Every time a fault occurs, we show which pages are in our three
                        frames. There are fifteen faults altogether.</p>
                    <p class="lead" style="color: red;">The FIFO page-replacement algorithm is easy to understand and program.
                        However, its performance is not always good. </p>
                    <p class="lead">To illustrate the problems that are possible with a FIFO page-replacement
                        algorithm, consider the following reference string: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5.
                        </p>
                    <p class="lead">Notice that the number of faults for four frames
                        (ten) is greater than the number of faults for three frames (nine)! This most
                        unexpected result is known as Belady‚Äôs anomaly see below figure.</p>


                        <div class="s-content__media">
                            <div class="s-content__post-thumb"> 
                                <img src="Screenshot (447).png" 
                                        srcset="Screenshot (447).png 2100w, 
                                                Screenshot (447).png 1050w, 
                                                Screenshot (447).png 525w" style="width: 100%; margin-left: 0px" alt="">
                            </div>
                        </div> <!-- end s-content__media -->

                        <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">Belady‚Äôs anomaly</h2>
                    <p class="lead">for some page-replacement
                        algorithms, the page-fault rate may increase as the number of allocated frames
                        increases. </p>

                        <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">Optimal Page Replacement algorithm</h2>

                    <p class="lead">This algorithm is not actually implemented practically but this algoritm is uased as reference to comapare the algorithm
                        is efficient or not.
                    </p>
                    <p class="lead">The algorithm that has the lowest page-fault
                        rate of all algorithms and will never suffer from Belady‚Äôs anomaly</p>
                    <p class="lead">It is simply this:
                        Replace the page that will not be used for the longest period of time.</p>
                    <p class="lead">Use of this page-replacement algorithm guarantees the lowest possible pagefault rate for a fixed number of frames.</p>
                    <div class="s-content__media">
                        <div class="s-content__post-thumb"> 
                            <img src="Screenshot (448).png" 
                                    srcset="Screenshot (448).png 2100w, 
                                            Screenshot (448).png 1050w, 
                                            Screenshot (448).png 525w" style="width: 100%; margin-left: 0px" alt="">
                        </div>
                    </div> <!-- end s-content__media -->
                    <p class="lead">For example, on our sample reference string, the optimal page-replacement
                        algorithm would yield nine page faults, as shown in above figure.</p>
                    <p class="lead">The first three
                        references cause faults that fill the three empty frames.</p>
                    <p class="lead">. The reference to page
                        2 replaces page 7, because page 7 will not be used until reference 18, whereas
                        page 0 will be used at 5, and page 1 at 14. The reference to page 3 replaces
                        page 1, as page 1 will be the last of the three pages in memory to be referenced
                        again.</p>
                    <p class="lead"> With only nine page faults, optimal replacement is much better than
                        a FIFO algorithm, which results in fifteen faults. (If we ignore the first three,
                        which all algorithms must suffer, then optimal replacement is twice as good as
                        FIFO replacement.) </p>
                    <p class="lead" style="color: red;">Unfortunately, the optimal page-replacement algorithm is difficult to
                        implement, because it requires future knowledge of the reference string.</p>


                        <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">LRU Page Replacement</h2>

                    <p class="lead">If the optimal algorithm is not feasible, perhaps an approximation of the
                        optimal algorithm is possible.</p>
                    <p class="lead">If we use the recent
                        past as an approximation of the near future, then we can replace the page that
                        has not been used for the longest period of time. This approach is the least
                        recently used (LRU) algorithm.</p>
                    <p class="lead">The result of applying LRU replacement to our example reference string is
                        shown in Figure below.</p>


                        <div class="s-content__media">
                            <div class="s-content__post-thumb"> 
                                <img src="Screenshot (449).png" 
                                        srcset="Screenshot (449).png 2100w, 
                                                Screenshot (449).png 1050w, 
                                                Screenshot (449).png 525w" style="width: 100%; margin-left: 0px" alt="">
                            </div>
                        </div> <!-- end s-content__media -->
                    <p class="lead">The LRU algorithm produces twelve faults. Notice that
                        the first five faults are the same as those for optimal replacement.</p>
                    <p class="lead">When the
                        reference to page 4 occurs, however, LRU replacement sees that, of the three
                        frames in memory, page 2 was used least recently. Thus, the LRU algorithm
                        replaces page 2, not knowing that page 2 is about to be used. </p>
                    <p class="lead">When it then faults
                        for page 2, the LRU algorithm replaces page 3, since it is now the least recently
                        used of the three pages in memory. Despite these problems, LRU replacement
                        with twelve faults is much better than FIFO replacement with fifteen.</p>
                    <p class="lead"> An LRU page-replacement algorithm may require substantial
                        hardware assistance. The problem is to determine an order for the frames
                        defined by the time of last use. Two implementations are feasible:</p>
                    <p class="lead">1. Counters</p>
                    <p class="lead">2. Stack</p>


                    <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">Counters</h2>

                    <p class="lead">In the simplest case, we associate with each page-table entry a
                        time-of-use field and add to the CPU a logical clock or counter.</p>
                    <p class="lead">The clock is
                        incremented for every memory reference. Whenever a reference to a page
                        is made, the contents of the clock register are copied to the time-of-use
                        field in the page-table entry for that page. </p>
                    <p class="lead">In this way, we always have the ‚Äútime‚Äù of the last reference to each page.</p>
                    <p class="lead">We replace the page with the
                        smallest time value. This scheme requires a search of the page table to find
                        the LRU page and a write to memory (to the time-of-use field in the page
                        table) for each memory access.</p>
                    <p class="lead"> The times must also be maintained when
                        page tables are changed (due to CPU scheduling). Overflow of the clock
                        must be considered.</p>

                    <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">Stack</h2>

                    <p class="lead">Whenever a page is referenced, it is removed
                        from the stack and put on the top.</p>
                    <p class="lead"> In this way, the most recently used
                        page is always at the top of the stack and the least recently used page is
                        always at the bottom (Figure 9.16). Because entries must be removed from
                        the middle of the stack, it is best to implement this approach by using a
                        doubly linked list with a head pointer and a tail pointer.</p>
                    <p class="lead">Removing a page
                        and putting it on the top of the stack then requires changing six pointers
                        at worst. Each update is a little more expensive, but there is no search for
                        a replacement; the tail pointer points to the bottom of the stack, which is
                        the LRU page. This approach is particularly appropriate for software or
                        microcode implementations of LRU replacement.</p>
                    <p class="lead" style="color: blue;"> Both optimal replacement, LRU replacement belong to a class of page-replacement algorithms, called stack
                        algorithms</p>
                    <p class="lead">A stack algorithm is an
                        algorithm for which it can be shown that the set of pages in memory for n
                        frames is always a subset of the set of pages that would be in memory with n
                        + 1 frames.</p>
                    <p class="lead">For LRU replacement, the set of pages in memory would be the n
                        most recently referenced pages. If the number of frames is increased, these n
                        pages will still be the most recently referenced and so will still be in memory</p>
                    <p class="lead" style="text-align: center;">Use of a stack to record the most recent page references</p>
                    <div class="s-content__media">
                        <div class="s-content__post-thumb"> 
                            <img src="Screenshot (450).png" 
                                    srcset="Screenshot (450).png 2100w, 
                                            Screenshot (450).png 1050w, 
                                            Screenshot (450).png 525w" style="width: 100%; margin-left: 0px" alt="">
                        </div>
                    </div> <!-- end s-content__media -->


                    <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">LRU-Approximation Page Replacement</h2>

                    <p class="lead">Many
                        systems provide some help, however, in the form of a reference bit.</p>
                    <p class="lead">The
                        reference bit for a page is set by the hardware whenever that page is referenced
                        (either a read or a write to any byte in the page). Reference bits are associated
                        with each entry in the page table.</p>
                    <p class="lead">Initially, all bits are cleared (to 0) by the operating system. As a user process
                        executes, the bit associated with each page referenced is set (to 1) by the
                        hardware.</p>
                    <p class="lead">After some time, we can determine which pages have been used and
                        which have not been used by examining the reference bits, although we do not
                        know the order of use.</p>


                        <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">a)
                             Additional-Reference-Bits Algorithm</h2>

                    <p class="lead">‚óè With each page associate a bit, initially = 0</p>
                    <p class="lead">‚óè When page is referenced bit set to 1</p>
                    <p class="lead">‚óè Replace any with reference bit = 0 (if one exists)</p>
                    <p class="lead">‚óè We do not know the order, however</p>

                    <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">a)
                        Second-Chance Algorithm</h2>
                    <p class="lead">When a page has been selected, however, we inspect its reference
                        bit. If the value is 0, we proceed to replace this page; but if the reference bit
                        is set to 1, we give the page a second chance and move on to select the next
                        FIFO page. </p>



                        <div class="s-content__media">
                            <div class="s-content__post-thumb"> 
                                <img src="Screenshot (451).png" 
                                        srcset="Screenshot (451).png 2100w, 
                                                Screenshot (451).png 1050w, 
                                                Screenshot (451).png 525w" style="width: 100%; margin-left: 0px" alt="">
                            </div>
                        </div> <!-- end s-content__media -->
                    <p class="lead">When a page gets a second chance, its reference bit is cleared, and
                        its arrival time is reset to the current time.</p>

                        <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">a)
                            Enhanced Second-Chance Algorithm</h2>
                    <p class="lead">We can enhance the second-chance algorithm by considering the reference bit
                        and the modify bit.</p>
                    <p class="lead">1. (0, 0) neither recently used nor modified‚Äîbest page to replace</p>
                    <p class="lead">2. (0, 1) not recently used but modified‚Äînot quite as good, because the
                        page will need to be written out before replacement</p>
                    <p class="lead">3. (1, 0) recently used but clean‚Äîprobably will be used again soon</p>
                    <p class="lead">4. (1, 1) recently used and modified‚Äîprobably will be used again soon, and
                        the page will be need to be written out to disk before it can be replaced</p>


                        <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">Counting-Based Page Replacement
                    </h2>
                    <p class="lead">There are many other algorithms that can be used for page replacement. For
                        example, we can keep a counter of the number of references that have been
                        made to each page and develop the following two schemes.</p>

                    
                        <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">1. least frequently used (LFU)</h2>
                    <p class="lead">replaces page with smallest count</p>
                    <p class="lead">The reason for this selection is
                        that an actively used page should have a large reference count. A problem
                        arises, however, when a page is used heavily during the initial phase of
                        a process but then is never used again. </p>
                    <h2 class="s-content__title s-content__title--post" style="font-size: 25px; text-align: left;">2. most frequently used (MFU)</h2>
                    <p class="lead">page-replacement algorithm is based
                        on the argument that the page with the smallest count was probably just
                        brought in and has yet to be used.</p>


                        <h2 class="s-content__title s-content__title--post" style="font-size: 30px; text-align: left;">Page-Buffering Algorithms</h2>
                    <p class="lead">Systems commonly keep a pool of free frames. When
                        a page fault occurs, a victim frame is chosen as before. However, the desired
                        page is read into a free frame from the pool before the victim is written out. </p>
                    <p class="lead">This
                        procedure allows the process to restart as soon as possible, without waiting
                        for the victim page to be written out. When the victim is later written out, its
                        frame is added to the free-frame pool.</p>
                    <p class="lead">Another modification is to keep a pool of free frames but to remember
                        which page was in each frame.</p>
                    <p class="lead">Since the frame contents are not modified when
                        a frame is written to the disk, the old page can be reused directly from the
                        free-frame pool if it is needed before that frame is reused.</p>
                    <p class="lead">No I/O is needed in
                        this case. When a page fault occurs, we first check whether the desired page is
                        in the free-frame pool. If it is not, we must select a free frame and read into it.</p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>
                    <p class="lead"></p>

                    

                    
                    

                </article>

                <div class="s-content__pagenav group">
                    <div class="next-nav" style="text-align: left;">
                        <a href="xv6 code- traps,scheduler,blocking.html" rel="next">
                           Previous
                        </a>
                    </div>

                    <div class="next-nav" style="text-align: right;">
                        <a href="../comingsoon.html" rel="next">
                           Next
                        </a>
                    </div>
                </div> <!-- end s-content__pagenav -->

                <a href="menu.html"><h3 class="s-content__title s-content__title--post" style="font-size: 20px;">Go to index page</h3></a>

            </div>  
        </div>                

    </section> <!-- end s-content -->


    <!-- footer
    ================================================== -->
    <footer class="s-footer">

        

        <div class="s-footer__bottom">
            <div class="row">
                <div class="column">
                    <div class="ss-copyright">
                        <span>¬© Copyright Suraj 2021</span> 
                        <span>Course by <a href="../index.html">Suraj</a></span>                 
                    </div> <!-- end ss-copyright -->
                </div>
            </div> 

            <div class="ss-go-top">
                <a class="smoothscroll" title="Back to Top" href="#top">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 4h12v2H6zm5 10v6h2v-6h5l-6-6-6 6z"/></svg>
                </a>
            </div> <!-- end ss-go-top -->
        </div> <!-- end s-footer__bottom -->

   </footer> <!-- end s-footer -->


   <!-- Java Script
   ================================================== --> 
   <script src="../js/jquery-3.2.1.min.js"></script>
   <script src="../js/plugins.js"></script>
   <script src="../js/main.js"></script>

</body>

</html>